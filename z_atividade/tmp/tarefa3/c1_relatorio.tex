\documentclass[10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage[a4paper, margin=1.5cm]{geometry}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.95}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\scriptsize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\title{Tarefa 3: Criação e identificação de processos}
\author{Seu Nome}
\date{\today}

\begin{document}

\maketitle
\thispagestyle{empty}

\section{Introducao}

Este relatório analisa programas em C que demonstram a criação e identificação de processos usando as funções \texttt{getpid()}, \texttt{getppid()} e \texttt{fork()}. Os arquivos seguem uma organização didática com prefixos (a1\_, a2\_).

\section{Implementação}

\subsection{Programas Desenvolvidos}

Dois programas foram implementados: o primeiro obtém e exibe o PID e PPID do processo atual, enquanto o segundo demonstra a criação de um processo filho usando \texttt{fork()}.

\begin{lstlisting}[language=C, caption=a1\_process\_id.c]
// Programa 1: Identificacao de Processos
#include <stdio.h>
#include <unistd.h>

int main() {
    printf("PID: %d, PPID: %d\n", getpid(), getppid());
    sleep(15);  // Para observacao do processo
    return 0;
}
\end{lstlisting}

\begin{lstlisting}[language=C, caption=a2\_fork\_process.c]
// Programa 2: Criacao de Processos com Fork
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int main() {
    pid_t child_pid;
    printf("Before fork - PID: %d, PPID: %d\n", getpid(), getppid());
    child_pid = fork();
    
    if (child_pid < 0) {
        perror("Fork failed"); exit(1);
    } else if (child_pid == 0) {
        printf("Child - PID: %d, PPID: %d\n", getpid(), getppid());
    } else {
        printf("Parent - PID: %d, PPID: %d, Child: %d\n", 
               getpid(), getppid(), child_pid);
    }
    sleep(30);  // Para observacao dos processos
    return 0;
}
\end{lstlisting}



\section{Resultados e Observações}

\subsection{Execução e Observação dos Programas}

\textbf{Programa 1 (process\_id):}
\begin{itemize}\itemsep0em
    \item O PID muda a cada execução, recebendo um valor único.
    \item O PPID permanece constante para execuções do mesmo terminal.
    \item Os valores de PID geralmente são incrementais, com possíveis lacunas.
\end{itemize}

\textbf{Programa 2 (fork\_process):}
\begin{itemize}\itemsep0em
    \item Após o \texttt{fork()}, dois processos executam simultaneamente.
    \item O processo filho recebe novo PID, diferente do pai.
    \item O PPID do filho é o PID do pai, estabelecendo relação hierárquica.
    \item \texttt{fork()} retorna valores diferentes: no pai, o PID do filho; no filho, 0.
    \item Ambos processos continuam a execução a partir do mesmo ponto.
\end{itemize}

\textbf{Observação em Tempo Real:}
\begin{itemize}\itemsep0em
    \item A estrutura hierárquica é visível com \texttt{ps --forest} ou \texttt{pstree}.
    \item Ambos processos têm a mesma imagem executável.
    \item O SO trata os processos como entidades independentes.
    \item Cada processo possui seu próprio espaço de memória e recursos.
\end{itemize}

\section{Respostas às Questões}

\subsection{Diferenca entre getpid() e getppid()}

\texttt{getpid()} retorna o identificador do processo atual, enquanto \texttt{getppid()} retorna o identificador do processo pai.

\begin{itemize}\itemsep0em
    \item \textbf{getpid():} Retorna o identificador único do processo em execução, atribuído pelo kernel na criação do processo. Este valor é usado pelo SO para identificar, rastrear e gerenciar o processo.
    
    \item \textbf{getppid():} Retorna o identificador do processo que criou o processo atual, estabelecendo uma relação hierárquica. Se o pai terminar antes do filho, o PPID é atualizado para o PID do processo \texttt{init} (geralmente 1).
\end{itemize}

\subsection{PID do processo filho após o fork()}

Após \texttt{fork()}, o processo filho recebe um novo PID único:

\begin{itemize}\itemsep0em
    \item O filho é uma cópia do pai, mas com identidade própria.
    \item O novo PID é geralmente o próximo disponível na sequência de PIDs.
    \item O PPID do filho corresponde ao PID do pai, estabelecendo a relação hierárquica.
    \item \texttt{fork()} retorna o PID do filho no processo pai e 0 no processo filho.
\end{itemize}

Isso permite que o SO gerencie os processos independentemente, controlando a execução e alocando recursos a cada um.

\subsection{Identificacao e organizacao de processos pelo SO}

O sistema operacional identifica e organiza processos atraves de:

\begin{itemize}\itemsep0em
    \item \textbf{Tabela de Processos:} Contem entradas para cada processo com informacoes como PID, PPID, estado, contexto, etc.
    \item \textbf{PIDs:} Identificadores unicos usados em chamadas de sistema, sinais e gerenciamento.
    \item \textbf{Hierarquia:} Estrutura de arvore onde cada processo (exceto init) tem um pai.
    \item \textbf{Estados:} Pronto, em execucao, bloqueado, parado ou zumbi.
    \item \textbf{Grupos e sessoes:} Para controle de terminais e gerenciamento de jobs.
    \item \textbf{Interface \texttt{/proc}:} Sistema de arquivos virtual que expoe informacoes de processos.
\end{itemize}

\subsection{Numero de impressoes apos o fork()}

E possivel prever as impressoes apos \texttt{fork()} entendendo seu comportamento:

\begin{itemize}\itemsep0em
    \item Se houver um \texttt{printf()} sem condicionais após \texttt{fork()}, será executado duas vezes (pai e filho).
    \item Com condicionais baseadas no retorno de \texttt{fork()}, cada bloco será executado pelo processo apropriado:
      \begin{itemize}\itemsep0em
        \item \texttt{if (pid == 0)} → apenas pelo filho
        \item \texttt{else} → apenas pelo pai
      \end{itemize}
    \item Múltiplos \texttt{fork()} em cascata seguem progressão exponencial.
\end{itemize}

No programa \texttt{a2\_fork\_process.c}, temos 3 impressões: uma antes do fork e uma para cada processo após o fork.

\subsection{Múltiplos processos com identidades distintas}

Um programa pode ter múltiplos processos com identidades distintas porque:

\begin{itemize}\itemsep0em
    \item \textbf{Separação código/estado:} Programa (instruções) vs. processo (instância dinâmica).
    \item \textbf{Paralelismo:} Aproveitamento de múltiplos cores para tarefas simultâneas.
    \item \textbf{Isolamento:} Cada processo tem seu próprio espaço de endereçamento.
    \item \textbf{Design do \texttt{fork()}:} Criado especificamente para clonar processos.
    \item \textbf{Modelo cliente-servidor:} Um processo por conexão/requisição.
    \item \textbf{Balanceamento:} Distribuição de carga entre múltiplas instâncias.
\end{itemize}

\section{Conclusao}

Este trabalho permitiu compreender o funcionamento de processos em sistemas Unix/Linux atraves das funcoes \texttt{getpid()}, \texttt{getppid()} e \texttt{fork()}. Os experimentos demonstraram que:

\begin{itemize}\itemsep0em
    \item Cada processo possui identidade unica (PID) atribuida pelo SO.
    \item A funcao \texttt{fork()} cria um novo processo como copia do original.
    \item Processos sao organizados hierarquicamente em estrutura de arvore.
    \item Um mesmo executavel pode gerar multiplos processos independentes.
    \item O SO mantem estruturas para rastrear e gerenciar processos ativos.
\end{itemize}

A compreensao destes conceitos e essencial para o desenvolvimento de software que utiliza concorrencia, paralelismo ou requer isolamento de falhas. O modelo de processos continua sendo fundamental nos sistemas operacionais modernos, proporcionando a base para aplicacoes robustas e eficientes que aproveitam ao maximo os recursos computacionais.

\end{document}
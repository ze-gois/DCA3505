\documentclass[a4paper,11pt]{article}

% Packages
\usepackage[brazilian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{geometry}
\geometry{margin=2.5cm}

% Configuração para código
\definecolor{codebackground}{rgb}{0.95,0.95,0.95}
\definecolor{codestring}{rgb}{0.58,0.0,0.82}
\definecolor{codemain}{rgb}{0.0,0.0,0.0}
\definecolor{codekeyword}{rgb}{0.0,0.0,0.75}
\definecolor{codecomment}{rgb}{0.0,0.5,0.0}

\lstset{
  backgroundcolor=\color{codebackground},
  basicstyle=\ttfamily\small,
  keywordstyle=\color{codekeyword}\bfseries,
  stringstyle=\color{codestring},
  commentstyle=\color{codecomment}\itshape,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  keepspaces=true,
  numbers=left,
  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=2,
  frame=single,
  framexleftmargin=7mm,
  framexrightmargin=1mm,
  framexbottommargin=4mm,
  framextopmargin=4mm,
  xleftmargin=7mm,
  xrightmargin=1mm
}

\lstdefinelanguage{C}{
  language=C,
  morekeywords={pid_t},
}

\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  filecolor=magenta,
  urlcolor=cyan,
}

\title{\textbf{Relatório: Criação e Identificação de Processos}}
\author{Sistemas Operacionais I}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Introdução}

Este relatório apresenta uma análise detalhada sobre a criação e identificação de processos em sistemas Linux através da implementação de programas em linguagem C. Exploramos as funções \texttt{getpid()}, \texttt{getppid()} e \texttt{fork()} para entender o comportamento dos processos, sua hierarquia e como o sistema operacional os gerencia.

\section{Programas Desenvolvidos}

\subsection{Programa 1: Identificação de Processo (pid\_info.c)}

O primeiro programa criado mostra informações básicas sobre o identificador do processo atual (PID) e o identificador do processo pai (PPID):

\begin{lstlisting}[language=C, caption=Programa pid\_info.c]
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid = getpid();
    pid_t ppid = getppid();

    printf("Informações do Processo:\n");
    printf("PID (Process ID): %d\n", pid);
    printf("PPID (Parent Process ID): %d\n", ppid);

    return 0;
}
\end{lstlisting}

\subsection{Programa 2: Criação de Processos (fork\_example.c)}

O segundo programa utiliza a função \texttt{fork()} para criar um processo filho, demonstrando a bifurcação de execução:

\begin{lstlisting}[language=C, caption=Programa fork\_example.c]
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>

int main() {
    pid_t pid;

    // Fork and create a child process
    pid = fork();

    // Check if fork() was successful
    if (pid < 0) {
        // Fork failed
        fprintf(stderr, "Erro ao criar processo filho\n");
        return 1;
    }
    else if (pid == 0) {
        // This code runs in the child process (pid = 0 in the child)
        printf("=== PROCESSO FILHO ===\n");
        printf("PID do filho: %d\n", getpid());
        printf("PPID do filho (PID do pai): %d\n", getppid());
        printf("O valor de pid para o filho é: %d\n", pid);

        // Adding a small delay to allow the parent process to be observed
        sleep(5);
        printf("Processo filho finalizando...\n");
    }
    else {
        // This code runs in the parent process (pid = PID of the child)
        printf("=== PROCESSO PAI ===\n");
        printf("PID do pai: %d\n", getpid());
        printf("PPID do pai: %d\n", getppid());
        printf("PID do filho criado: %d\n", pid);

        // Wait for the child to finish
        int status;
        waitpid(pid, &status, 0);
        printf("Processo pai finalizando após o término do filho...\n");
    }

    return 0;
}
\end{lstlisting}

\section{Resultados e Observações}

\subsection{Execução Múltipla do pid\_info}

Após executar o programa \texttt{pid\_info} múltiplas vezes, observamos que:

\begin{enumerate}
    \item O PID é diferente em cada execução, geralmente incrementando sequencialmente (37525, 37526, 37527, etc.).
    \item O PPID permaneceu constante (37522) entre execuções, indicando que todas as execuções foram iniciadas pelo mesmo processo pai (o shell).
    \item A taxa de incremento do PID pode variar dependendo da atividade do sistema.
\end{enumerate}

\subsection{Comportamento com fork()}

Na execução do \texttt{fork\_example}, observamos:

\begin{enumerate}
    \item O processo pai recebeu um PID único (37530) e reportou o PPID (37522) do shell que o executou.
    \item O processo filho recebeu seu próprio PID único (37531).
    \item O PPID do processo filho é igual ao PID do processo pai, confirmando a relação pai-filho.
    \item O valor retornado por \texttt{fork()} é diferente no pai (PID do filho) e no filho (sempre zero).
\end{enumerate}

\subsection{Observação com ps}

Usando o comando \texttt{ps} durante a execução do programa com fork, pudemos visualizar:

\begin{enumerate}
    \item Os dois processos (pai e filho) aparecendo na lista de processos ativos.
    \item A hierarquia entre eles, com o PPID do filho apontando para o PID do pai.
    \item Ambos processos executando o mesmo programa (\texttt{fork\_example}), mas com PIDs distintos.
\end{enumerate}

\section{Experimento de Oscilação de PIDs}

Para entender melhor como o sistema operacional atribui PIDs em um ambiente com alta atividade, realizamos um experimento adicional criando processos em background e matando-os aleatoriamente enquanto monitorávamos as atribuições de PID.

\subsection{Configuração do Experimento}

Desenvolvemos os seguintes programas e scripts:

\begin{enumerate}
    \item \textbf{infinite\_loop.c}: Um programa C que executa um loop infinito até ser morto, coletando estatísticas de execução.
    \item \textbf{spawn\_processes.sh}: Script que cria múltiplos processos de loop infinito em background.
    \item \textbf{kill\_random.sh}: Script que mata aleatoriamente processos criados anteriormente.
    \item \textbf{pid\_chaos\_demo.sh}: Script principal que orquestra a criação e destruição de processos enquanto observa o comportamento dos PIDs.
\end{enumerate}

O programa \texttt{infinite\_loop.c} foi projetado para demonstrar o comportamento de processos em execução contínua:

\begin{lstlisting}[language=C, caption=Programa infinite\_loop.c]
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <time.h>
#include <string.h>

// Flag for graceful termination
volatile sig_atomic_t running = 1;

// Signal handler for graceful termination
void handle_signal(int sig) {
    printf("\nProcess %d received signal %d, terminating gracefully...\n", getpid(), sig);
    running = 0;
}

// Function to display memory usage
void show_memory_info() {
    char buffer[128];
    FILE* fp = fopen("/proc/self/status", "r");
    if (fp == NULL) return;

    size_t vm_size = 0, vm_rss = 0;

    while (fgets(buffer, sizeof(buffer), fp) != NULL) {
        if (strncmp(buffer, "VmSize:", 7) == 0) {
            sscanf(buffer, "VmSize: %zu", &vm_size);
        }
        if (strncmp(buffer, "VmRSS:", 6) == 0) {
            sscanf(buffer, "VmRSS: %zu", &vm_rss);
        }
    }

    fclose(fp);
    printf("Memory usage: VmSize: %zu KB, VmRSS: %zu KB\n", vm_size, vm_rss);
}

int main(int argc, char *argv[]) {
    // Register signal handlers
    signal(SIGTERM, handle_signal);
    signal(SIGINT, handle_signal);

    // Get process information
    pid_t pid = getpid();
    pid_t ppid = getppid();

    // Random seed based on PID
    srand(pid);

    // Determine the loop count (default or from arguments)
    unsigned long loop_count = 0;
    int sleep_time = 1;

    if (argc > 1) {
        sleep_time = atoi(argv[1]);
        if (sleep_time <= 0) sleep_time = 1;
    }

    // Print starting message with timestamp
    char timestamp[64];
    time_t now = time(NULL);
    strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M:%S", localtime(&now));

    printf("[%s] Process %d started (Parent: %d)\n", timestamp, pid, ppid);
    printf("Process will wait %d second(s) between iterations\n", sleep_time);
    show_memory_info();

    // Main loop
    while (running) {
        // Update loop count and periodically print status
        loop_count++;
        if (loop_count % 5 == 0) {
            now = time(NULL);
            strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M:%S", localtime(&now));
            printf("[%s] Process %d still running (iteration %lu)\n",
                  timestamp, pid, loop_count);
            show_memory_info();
        }

        // Sleep to reduce CPU usage
        sleep(sleep_time);
    }

    // Print final statistics
    now = time(NULL);
    strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M:%S", localtime(&now));
    printf("[%s] Process %d completed after %lu iterations\n", timestamp, pid, loop_count);

    return 0;
}
\end{lstlisting}

Este programa demonstra vários conceitos importantes:
\begin{itemize}
    \item Identificação do processo e seu pai através de \texttt{getpid()} e \texttt{getppid()}
    \item Tratamento de sinais para terminação graciosa
    \item Acesso a informações de recursos do processo via \texttt{/proc/self/status}
    \item Registro de timestamping para análise temporal de eventos
\end{itemize}

\subsection{Resultados Observados}

\begin{table}[h]
\centering
\begin{tabular}{@{}cllcc@{}}
\toprule
\textbf{Execução} & \textbf{Contexto} & \textbf{PID} & \textbf{PPID} & \textbf{Incremento} \\
\midrule
1 & Estado inicial & 38568 & 38560 & - \\
2 & Após criar 7 processos & 38593 & 38560 & +25 \\
3 & Após matar 2 processos & 38604 & 38560 & +11 \\
4 & Após criar 11 processos & 38639 & 38560 & +35 \\
5 & Após matar 3 processos & 38651 & 38560 & +12 \\
6-11 & Durante ciclos rápidos & 38662-38727 & 38560 & Variados \\
12 & Após limpeza final & 38732 & 38560 & +5 \\
\bottomrule
\end{tabular}
\caption{Variação nos valores de PID durante o experimento de oscilação}
\label{tab:pid_oscillation}
\end{table}

\subsection{Conclusões do Experimento}

\begin{enumerate}
    \item \textbf{Incremento não linear}: Os PIDs não aumentam por um valor fixo entre execuções.
    \item \textbf{Influência da atividade do sistema}: A taxa de incremento dos PIDs é diretamente proporcional à atividade de criação e destruição de processos no sistema.
    \item \textbf{Não reutilização imediata}: O Linux não reutiliza imediatamente os PIDs de processos recém-terminados por questões de segurança.
    \item \textbf{Comportamento do contador}: O Linux utiliza um contador monotônico crescente para atribuir PIDs, que só retorna ao início após atingir o valor máximo (definido em \texttt{/proc/sys/kernel/pid\_max}).
\end{enumerate}

\section{Perguntas e Respostas}

\subsection{Qual é a diferença entre getpid() e getppid()? O que eles representam?}

\begin{itemize}
    \item \textbf{getpid()}: Retorna o identificador único (PID) do processo que está executando a chamada. Este identificador é atribuído pelo sistema operacional quando o processo é criado.
    \item \textbf{getppid()}: Retorna o identificador do processo pai (PPID), ou seja, o PID do processo que criou o processo atual.
\end{itemize}

Esses identificadores são essenciais para o sistema operacional controlar, monitorar e gerenciar os processos em execução. O PID é único para cada processo ativo no sistema, enquanto o PPID estabelece a relação hierárquica entre processos.

\subsection{O que acontece com o PID do processo filho após o fork()?}

Após um \texttt{fork()}, o sistema operacional cria um novo processo (filho) que é praticamente uma cópia do processo original (pai). O processo filho recebe um novo PID único, diferente do PID do pai. O sistema operacional geralmente atribui PIDs sequencialmente, então o PID do filho é frequentemente o próximo número disponível na sequência.

Nos testes realizados, observamos que o processo filho obteve um PID único (exemplo: 37531), enquanto seu PPID era o PID do processo pai (37530), estabelecendo claramente a relação de parentesco entre os processos.

\subsection{Como o sistema operacional identifica e organiza os processos em execução?}

O sistema operacional Linux organiza os processos em uma estrutura hierárquica, conhecida como "árvore de processos". Cada processo, exceto o processo inicial (init/systemd, PID 1), possui um processo pai. Esta organização é mantida através dos PIDs e PPIDs.

O kernel mantém uma tabela de processos (\texttt{task\_struct} no Linux) que contém informações sobre cada processo, incluindo:
\begin{itemize}
    \item PID único
    \item PPID (processo pai)
    \item Estado do processo (executando, dormindo, zombi, etc.)
    \item Recursos alocados (memória, arquivos abertos)
    \item Informações de programação (prioridade, tempo de CPU)
    \item Contexto de execução
\end{itemize}

Esta estrutura permite que o sistema operacional controle o ciclo de vida dos processos, gerencie recursos, programe a execução e estabeleça relações entre processos. Comandos como \texttt{ps}, \texttt{top} e \texttt{htop} utilizam essas informações para exibir detalhes sobre os processos em execução.

Para atribuir PIDs, o Linux utiliza um mecanismo de contador sequencial que:
\begin{enumerate}
    \item Mantém o próximo PID disponível em uma variável global
    \item Incrementa esta variável para cada novo processo criado
    \item Verifica se o novo valor já está em uso (caso tenha dado uma volta completa)
    \item Quando o contador atinge o valor máximo (\texttt{pid\_max}), retorna ao valor mínimo e busca PIDs disponíveis
\end{enumerate}

Este mecanismo explica por que observamos que os PIDs incrementam de forma variável durante nosso experimento, dependendo da atividade geral do sistema.

\subsection{É possível prever quantas vezes o programa imprimirá mensagens após o fork()? Justifique.}

Sim, é possível prever. Após um único \texttt{fork()} bem-sucedido, o programa imprimirá mensagens exatamente duas vezes:

\begin{enumerate}
    \item Uma vez no processo pai
    \item Uma vez no processo filho
\end{enumerate}

Isso ocorre porque o \texttt{fork()} cria uma cópia quase idêntica do processo, incluindo o contador de programa (PC). Após o \texttt{fork()}, ambos os processos continuam executando o código a partir do mesmo ponto, mas em espaços de memória separados e com valores de retorno diferentes da função \texttt{fork()}:
\begin{itemize}
    \item No processo pai: retorna o PID do filho
    \item No processo filho: retorna 0
\end{itemize}

Com base nisso, os dois processos seguem caminhos de execução distintos no código usando a verificação condicional \texttt{if (pid == 0)}, resultando em duas sequências de mensagens.

Se múltiplos \texttt{fork()} forem encadeados sem verificações adequadas, o número de processos (e mensagens) cresceria exponencialmente ($2^n$ para n chamadas de fork).

\subsection{Por que o mesmo programa pode ter múltiplos processos com identidades distintas?}

Um programa pode ter múltiplos processos com identidades distintas porque, no contexto de sistemas operacionais, existe uma diferença fundamental entre um programa e um processo:

\begin{itemize}
    \item \textbf{Programa}: É um arquivo executável que contém código e instruções armazenados em disco.
    \item \textbf{Processo}: É uma instância em execução de um programa, com seu próprio espaço de endereçamento, contador de programa, registradores e recursos do sistema.
\end{itemize}

Quando um programa é executado, o sistema operacional cria um processo para ele. Quando usamos \texttt{fork()}, criamos um novo processo que executa o mesmo código, mas tem sua própria identidade (PID) e cópia independente do espaço de memória. Isso permite que o mesmo código seja executado em contextos diferentes, com dados diferentes.

Esta capacidade é fundamental para a concorrência em sistemas operacionais e permite:
\begin{enumerate}
    \item Servidores web que atendem múltiplas requisições simultaneamente
    \item Shells que executam comandos em background
    \item Aplicações multitarefa que executam operações paralelas
\end{enumerate}

Os testes realizados demonstraram claramente que mesmo sendo o mesmo código (programa), cada execução ou instância após um \texttt{fork()} recebe uma identidade única (PID) do sistema operacional, permitindo que múltiplas cópias do mesmo programa sejam executadas e gerenciadas independentemente.

Nosso experimento de caos de PIDs mostrou ainda que, mesmo quando executamos repetidamente o mesmo programa (\texttt{pid\_info}), cada instância recebe um novo PID que depende da atividade geral do sistema. Por exemplo, após criar 7 processos em background, o próximo PID atribuído saltou 25 unidades, mostrando como a atribuição de PIDs é influenciada dinamicamente pela atividade do sistema.

\section{Conclusão}

Através dos experimentos realizados, pudemos compreender na prática como o sistema operacional Linux gerencia processos. As funções \texttt{getpid()}, \texttt{getppid()} e \texttt{fork()} permitem visualizar e manipular a estrutura hierárquica de processos, demonstrando como o sistema operacional mantém a organização mesmo quando múltiplos processos executam o mesmo código.

Nossa investigação adicional sobre a oscilação de PIDs revelou o comportamento dinâmico e não-determinístico da atribuição de identificadores de processo. Demonstramos que:

\begin{enumerate}
    \item Os PIDs são atribuídos de forma sequencial, mas com incrementos variáveis
    \item A atividade geral do sistema influencia diretamente a taxa de incremento dos PIDs
    \item O sistema operacional não reutiliza imediatamente PIDs de processos terminados
    \item Mesmo em um ambiente controlado, a atribuição de PIDs é influenciada por fatores externos
\end{enumerate}

A criação deliberada de processos em background e sua terminação aleatória nos permitiu observar de forma controlada o comportamento não-determinístico da atribuição de PIDs, confirmando que o valor do próximo PID é sensível à atividade do sistema como um todo, não apenas à atividade do usuário atual.

Esta capacidade de criar e gerenciar múltiplos processos, cada um com sua identidade única, é um dos fundamentos dos sistemas operacionais modernos, permitindo multitarefa, paralelismo e utilização eficiente dos recursos do sistema.

\end{document}
